{
  "api/index.html": {
    "href": "api/index.html",
    "title": "CodeFactory SDK Documentation | CodeFactory Guidance",
    "keywords": "CodeFactory SDK Documentation This provides direct access to API level documentation for the CodeFactory SDK. In order to use the SDK you will need to have CodeFactory for Visual Studio Insalled. If you do not have the Runtime installed see the following guidance. CodeFactory Installation You will also need to have the CodeFactory SDK installed. If you do not have the SDK installed see the following guidance. CodeFactory SDK Installation"
  },
  "guidance/howto/CreateProject/AutomateProjectInformation.html": {
    "href": "guidance/howto/CreateProject/AutomateProjectInformation.html",
    "title": "Automate Project Information | CodeFactory Guidance",
    "keywords": "Automate Project Information In this section we will be using CodeFactory to get information about a project, hosted within a Visual Studio solution, and displaying it. This guidiance is expected to accomplish the following: How to format a CodeFactory command How to consume data from the CodeFactory Framework How to create a user interface and display data from CodeFactory Assumptions We recommend completing the guidance for Creating a Project prior to starting on this guidance. Click the link below and complete the first part before continuing. Creating A Project Goals In this section we are going to create a project command that will display information about the project itself. The following information will be displayed about the project itself: Project Name Number of project files Number of project references CodeFactory Command Information CodeFactory commands are raised directly by Visual Studio through the CodeFactory Framework. Command Title All CodeFactory commands have a title that is displayed in Visual Studio context menus. The field commandTitle that is hosted within the target command class is where the title for the command is set. Command Description All CodeFactory commands have a description that is used on summary screens to explain what the command is used for. The field commandDescription that is hosted within the target command class is where the description is set. Enable Command Every command has an override for the method EnableCommandAsync and it provides the Datamodel for the target Solution Explorer element that it represents. The CodeFactory Framework calls this method to determine whether or not this command should be displayed to the user in Visual Studio. There are times that command should not be displayed. For example: If we want to add missing members to a class or, if no members are missing, we would not show the command. With this in mind, the enable command allows you to use the data in the data model to determine if a command should be enabled for usage. The return from this method is true or false. If set to true, the command will be displayed on the context menu. If set to false, it will not show up on the context menu and no further execution will be performed. Execute Command Once a command has been enabled and the user has selected the command from the context menu, CodeFactory will execute the command. CodeFactory will call the Overridden ExecuteCommandAsync implemented in your command class. Like with the enable command it will provide the current data for the target solution explorer element. This is where CodeFactory will execute your custom automation. Command Implementation In this section we will implement all the logic that will display the project information. This has been broken down in to sub-sections to provide greater clarity on each set of steps. Format the Command Before we begin the automation logic we need to format the command so it is ready for usage by staff. The following steps will be taken to format the command: Update the Command Title and Description First we need to set the title and the description of the command so they display correctly in Visual Studio. The following steps will be performed in the ProjectInformationCommand.cs code file: We update the command title to Show Project Information. From: private static readonly string commandTitle = \"Replace with command title to be displayed in context menu\"; To: private static readonly string commandTitle = \"Show Project Information\"; We update the command description to Displays basic information about the project. From: private static readonly string commandDescription = \"Replace with description of what this command does\"; To: private static readonly string commandDescription = \"Displays basic information about the project\"; Once updated should look like this. Setup then Enable Command Since we are displaying information about a project, there are no extended conditions to validate, we will just make sure we received a loaded data model from CodeFactory. CodeFactory already gives us a fully templated out method. So we will replace the TODO with our enable logic. The provided method is shown below: We will replace the TODO line with a check to make sure the data model loaded. When a data model is loaded is has a property to determine if the data model was loaded or if it could not be loaded due to errors. By default the method has a isEnabled variable aready created so we will check to the model is loaded and set isEnabled based on if the model is loaded. From: //TODO: Add logic to determine if this command is enabled. To: isEnabled = result.IsLoaded; Once the code updates are completed, it should look like this: Testing the Formatted Command Before we dive into the logic, lets go ahead and test to make sure our command formatting is correct. So we are going to debug our automation we have created so far. Click Start Debugging this will be the \"Play\" button icon on your toolbar with the \"Start\" label next to it. You will notice that will start a new instance of Visual Studio. This is by design. CodeFactory automation runs inside of Visual Studio so we debug it from another instance. From the What would you like to do? window, click \"Create a new project\" Or you can start the same process if you don't use the start up window. Click the File menu From the context menu select New From the sub-context menu select Project From the \"Create a new project\" dialog do the following: In the search box type Standard Select C# Class Library (.NET Standard) Click the Next button From the \"Configure your new project\" dialog do the following: In the Project name text box enter CodeFactoryTesting. Click Create button Once the project and solution have been created they will load. We will reuse this project and solution for all further testing as we complete the automation for this project. To test the CodeFactory command we do the following: Right click on the Project node in Solution Explorer. From the context menu at the bottom you will see the Show Project Information command. Testing complete we know the command is running. Close the debugger instance of Visual Studio. Gather Project Information Now that the project command has been formatted we are ready to begin the automation logic. We need to get the following information and prepare it to be displayed to the user. Project Name - The name of the project itself Number of References - The count of how many references are tied to this project Number of Files - The number of files that are hosted in this project. This logic will be hosted directly in the execute command. This gets called by the CodeFactory Framework as soon as the command is selected from the context menu by a developer using our automation. When we created the project command class it automatically added the ExecuteCommandAsync method. Which looks like this: The following steps will be taken to add the project information logic to the ExecuteCommandAsync Method. We will replace the TODO block with a bounds check to make sure we got a project model that was loaded. If the model is not loaded will use a Messagebox to display a message explaining what happened. From: //TODO: Add command logic To: if (!result.IsLoaded) { MessageBox.Show(\"Could not access the project information. Cannot display the project information\", \"No Model Data\", MessageBoxButton.OK, MessageBoxImage.Exclamation); return; } Updated code will look like this: After our bounds check, we will add the three variables that will be used to store the project information to be displayed. string projectName = null; int projectReferences = 0; int projectFiles = 0; Updated code will look like this: Will capture the project name from the returned data model by entering the following: projectName = result.Name; Updated code will look like this: Next we will need to get the project references that are assigned to the project. This is done through a CodeFactory API call. Most CodeFactory API calls that talk to Visual Studio are done using an async call. This improves Visual Studio performance by running the tasks in the background, when possible. We get the references and add them to a var parameter to hold the references. Then we will get the count of all references and add it to our projectReferences variable. var references = await result.GetProjectReferencesAsync(); projectReferences = references.Count; Updated code will look like this: The final data needed from the project is the number of files that are hosted by the project. Like with project references we need to make a CodeFactory API call to get the real time data for each file and folder that is hosted in the project. This API call can access just the project root level, or access all nested levels under folders. We are going to tell it to get all nested levels. Since there are multiple different data models that represent Visual Studio data. The data that is returned as an inherited data type of all Visual Studio data called a VsModel. The inherited base class tells you what type of model is being represented. You can then cast the model to the target type and use it. A call is made to get all children of the project and stored in a var named projectChildren. Then, using a where clause on the projectChildren, we select all models that are a document and store it in a var named Files. Finally we set our projectFiles variable with the count of the found files. var projectChildren = await result.GetChildrenAsync(true); var files = projectChildren.Where(m => m.ModelType == VisualStudioModelType.Document); projectFiles = files.Count(); Updated code will look like this: Build Visual Studio Dialog Now that we have the project data that we need, we will then focus on building a dialog to display this information in Visual Studio. From Solution Explorer we are going to do the following. Right click on the Dialog folder under the project folder From the context menu select Add From the sub-context menu select New Item... From the Add New Item dialog, do the following: Under Visual C# Items select CodeFactory Select Visual Studio User Control In the name Field, enter ProjectInformationUserControl.xaml Click Add Now that the user control has been created it will open the user control XAML file. You will see the default markup for the user control itself. It will look like this: Next we are going to set the window title and set the target size of the dialog. We do this by updating the markup for the window title. We also replace the Design height and width. We set the height to 175 pixels and the width to 400 pixels. WindowTitle=\"Project Information\" Height=\"175\" Width=\"400\"> The updated markup will look like this: After we have setup our dialog and given it a title, we are going to use a grid layout to format the placement of our data. Since we are working with 3 elements of data we will create a grid with 5 rows and a total of 3 columns. <Grid.ColumnDefinitions> <ColumnDefinition Width=\"20\"/> <ColumnDefinition Width=\"150\"/> <ColumnDefinition/> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height=\"20\"/> <RowDefinition Height=\"30\"/> <RowDefinition Height=\"30\"/> <RowDefinition Height=\"30\"/> <RowDefinition /> </Grid.RowDefinitions> The updated markup will look like this: Once the layout has been setup, we will add label and text box controls for each piece of project data that is being added to the project. <Label Name=\"LabelProjectName\" Grid.Row=\"1\" Grid.Column=\"1\" Content=\"Project Name:\" HorizontalAlignment=\"Right\" Margin=\"0,0,5,0\"/> <TextBox Name=\"TextBoxProjectName\" Grid.Row=\"1\" Grid.Column=\"2\" Margin=\"5\" IsEnabled=\"False\"/> <Label Name=\"LabelProjectReferences\" Grid.Row=\"2\" Grid.Column=\"1\" Content=\"Project Reference Count:\" HorizontalAlignment=\"Right\" Margin=\"0,0,5,0\"/> <TextBox Name=\"TextBoxProjectReferences\" Grid.Row=\"2\" Grid.Column=\"2\" Margin=\"5\" Width=\"40\" HorizontalAlignment=\"Left\" IsEnabled=\"False\"/> <Label Name=\"LabelProjectFiles\" Grid.Row=\"3\" Grid.Column=\"1\" Content=\"Project File Count:\" HorizontalAlignment=\"Right\" Margin=\"0,0,5,0\"/> <TextBox Name=\"TextBoxProjectFiles\" Grid.Row=\"3\" Grid.Column=\"2\" Margin=\"5\" Width=\"40\" HorizontalAlignment=\"Left\" IsEnabled=\"False\"/> The updated markup will look like this: Next, we wire up the button and register a method to handle the Click event. <Button Name=\"ButtonOk\" Grid.Row=\"4\" Grid.Column=\"0\" Grid.ColumnSpan=\"3\" Margin=\"125,15\" Content=\"Ok\" Click=\"ButtonOk_OnClick\"/> Note in the IDE that when you enter the Click attribute it will prompt you to create a new method, let it create the method for you. The updated markup will look like this: The final layout of the user control will look like this: Now that the layout is complete we will access the code behind file for the user control and make some changes. To do this do the following: Click the expander next to the XAML document of the user control itself. Select the project file with the same name of the user control ending in .cs This will will open the code file for edit. After the code behind file has been opened, we are going update the OK button click event method to close the dialog itself. Those familar with WPF will know there is no close method for a user control. This close event is part of the CodeFactory framework and will inform Visual Studio to close the dialog window. The following code will be added to close the dialog when clicked: Before: throw new NotImplementedException(); After: this.Close(); The updated source code will look like this: The final step on the dialog is to be able to pass the project data to the user control. We will create a public facing method which will take in the three pieces of information and directly set each control individually. Those that are familar with WPF would probably used dependency properties. For this example we are keeping it simple for people that are not familar with WPF. The following method is added to the code behind to set the data. /// <summary> /// Sets the project information to be displayed in the dialog /// </summary> /// <param name=\"projectName\">The name of the project hosted in the solution.</param> /// <param name=\"fileCount\">The number of files hosted in the project.</param> /// <param name=\"referenceCount\">The number of references in the project.</param> public void SetProjectInformation(string projectName, int fileCount, int referenceCount) { this.TextBoxProjectName.Text = projectName; this.TextBoxProjectFiles.Text = fileCount.ToString(); this.TextBoxProjectReferences.Text = referenceCount.ToString(); } Create and Display Dialog Once we have created a dialog and formatted it. Next we will need to create an instance of the dialog user control. Then pass the data that has been collected on the project and display it. We navigate back to the ProjectInformationCommand code file. In the ExecuteCommandAsync method we are going to create an instance of the user control. When working with the user interface we have to make a CodeFactory API call to make the instance of the user control. Behind the covers, CodeFactory wraps the defined user control in a WPF dialog window used by Visual Studio. In order to access the user interface you have to use a Visual Studio Action. All commands have direct access to all Visual Studio Actions managed by CodeFactory via a property on the command base class. In the following we call the user interface actions and create a instance of our user control and return it to the var dialog. var dialog = await VisualStudioActions.UserInterfaceActions .CreateVsUserControlAsync<ProjectInformationUserControl>(); The updated code looks like the following: Once we have created an instance of dialog we will need to pass the project information to the dialog. We will call the public method we created and pass our project data to the dialog. dialog.SetProjectInformation(projectName,projectFiles,projectReferences); The updated code looks like the following: Now that our data has been set we are ready to display the dialog itself. Once again we will make a CodeFactory API call and display the dialog in Visual Studio. await VisualStudioActions.UserInterfaceActions.ShowDialogWindowAsync(dialog); The updated code looks like the following: Test Completed Command Now that the project information command has been completed, we will use the debugger to test the logic. Click Start Debugging (this will be the play button icon on your toolbar with star next to it). You will notice that this will start a new instance of Visual Studio. This is by design. CodeFactory automation runs inside of Visual Studio so we debug it from another instance. Once the debugger version of Visual Studio loads, do the following: Click File From the menu select Recent Projects and Solutions From the sub-menu select CodeFactoryTesting.sln This will load our testing solution. During the loading of the solution a number of services are loading. When in debugger mode this can be slow. You will know when your CodeFactory logic is loaded by seeing this message in the lower left hand corner of the window: Next, we execute the Project Information command and test our logic by doing the following: Right click on the project in the solution From the context menu click Show Project Infomation Visual Studio will then display the dialog with the information about the project. Click Ok to close the dialog Play with the project Make changes to the project itself, add code files. Maybe add a project reference and then rerun the command the dialog will show the updated information. Since this is in debug mode, you can go back to the hosting copy of Visual Studio and set break points. You can then step through the code and see how everything executes. Once you are done, close the debug version of Visual Studio. Deploying the Automation to Your Solutions Every time you build your project, the CodeFactory SDK calls an external executable called CFXPackager. This packages up your automation for using in solutions. In the bin folder of your project is a file with the name of your project with a .CFX file extension. Copy the CFX file into the solution folder of your target solution you want to use with automation and CodeFactory will load it whenever the solution opens. Return to Guidance This concludes the complete training for how to create a CodeFactory project. The link below will take you back to the main guidance page. CodeFactory Guidance Return To Create Project Guidance The link below will take you back to the Create Project guidance. Create Project Guidance"
  },
  "guidance/howto/CreateProject/CreateProject.html": {
    "href": "guidance/howto/CreateProject/CreateProject.html",
    "title": "Creating a Project | CodeFactory Guidance",
    "keywords": "Creating a Project The first step will be to create a project and register our first command. Background The following is important background information on CodeFactory itself. This will help you understand the default startup behavior the first time you create a CodeFactory project. NuGet CodeFactory was designed to load the target versions of the SDK libraries directly from NuGet. The way that this is accomplished is by adding direct project references to the target version hosted on NuGet. With the legacy project system used to host .Net framework it does not automatically pull down these NuGet packages when you load the project for the first time. So if any CodeFactory project items are added you will get a number of errors related to the libraries not being loaded. The NuGet packages will automatically be pulled down the first time you do a build (Ctrl-Shift-B) of the project itself, these errors will then go away. CodeFactory Packager A CodeFactory commands project is the main execution point for all CodeFactory automation. This project will automatically execute a command line utility after the compile of the project has completed. The CFXPackager utility is responsible for building the CFX file that is used to run CodeFactory automation. If no commands are defined in the project this utiltity will output a error saying the package could not be built. This error will go away once the first command is added to the project. Walk-through Steps Follow these steps to successfully create and compile your CodeFactory project: Start Visual Studio From the \"What would you like to do?\" window click \"Create a new project\". Or you can start the same process if you dont use the start up window. Click the File menu From the context menu select New From the sub-context menu select Project From the \"Create a new project\" window do the following: In the search box type CodeFactory From The list of projects select \"CodeFactory - Commands Library\" Click \"Next\" From the \"Configure your new project\" window do the following: In the \"project name\" box type \"DisplayProjectCommands\" Click Create Once the solution and project has been created you will see the project and default folder structure. I have expanded the Project folder to show you the sub-folders. The following is a brief overview of the goal for each folder. Important note: each Explorer Command has its own folder. The following structure is prescriptive only. You can create any folder structure you wish for your automation. The Project folder is where project commands are created and stored The Dialog folder is for placement of user interface dialogs you created. The Logic folder is where you add logic that can be reused across multiple project commands The Template folder is where you add T4 template that are used by project commands. Next we will add a solution explorer project command to the project. Do the following steps: Right click on the project folder in solution explorer From the context menu select Add From the sub context menu select New Item... From the Add New Item Dialog Window do the following: From the Visual C# Items select CodeFactory Select Solution Explorer - Project Command In the name box enter ProjectInformationCommand.cs Then click Add A Microsoft Visual Studio error box will appear. This error occurs because the CodeFactory SDK NuGet packages have not been downloaded into the project yet. This is normal. Click Ok to continue. The command code file will display in the IDE and a number of syntax errors will appear. This is occuring since we have not pulled down the SDK through NuGet yet. We will then Build the solution which will trigger the pull of the NuGet packages. Do the following: From the top navigation bar click on Build From the context menu click Build Solution Once the build has completed it will have downloaded and installed the NuGet packages into the project. You will now see the CodeFactorySDK reference in the project. You will also notice there are no longer any errors in the project command. The project creation is complete. Next Step - Automating Project Information In the next section we will build the logic to read information about a project and display it to the user in Visual Studio. Automate Project Information Return To Create Project Guidance The link below will take you back to the create project guidance. Create Project Guidance"
  },
  "guidance/howto/CreateProject/Overview.html": {
    "href": "guidance/howto/CreateProject/Overview.html",
    "title": "Creating a CodeFactory Project | CodeFactory Guidance",
    "keywords": "Creating a CodeFactory Project This section will explains how to use the CodeFactory SDK. In this walk-through we will focus on the following topics: How to create a CodeFactory project Understanding how NuGet packages are loaded for CodeFactory How to create a CodeFactory command How to format a CodeFactory command How to consume data from the CodeFactory Framework How to create a user interface and display data using CodeFactory Prequisites: Please confirm the following prior to getting started with this guidance: You are using Visual Studio (2019 or 2022) on Windows (Visual Studio on Mac is not currently supported). You have installed CodeFactory for Visual Studio and have activated CodeFactory with a license key. You have installed the CodeFactory SDK. This walk-through is grouped into logical exercises which address each of the guidance topics listed above. Part One - Creating a Project In the first part of the guidance, we will create a project and get it ready to build automation. This will focus on the following: How to create a CodeFactory project Understanding how NuGet packages are loaded for CodeFactory How to create a CodeFactory command Create a CodeFactory Project Part Two - Automate Project Information In the second part, we will gather & display information about a Visual Studio project for the Visual Studio user. This will focus on the following: How to format a CodeFactory command How to consume data from the CodeFactory Framework How to create a user interface and display data from CodeFactory Automate Project Information Guidance Once you have completed this set of lessons you can return to guidance by clicking the link below. CodeFactory Guidance"
  },
  "guidance/howto/Install/CodeFactoryForVisualStudio.html": {
    "href": "guidance/howto/Install/CodeFactoryForVisualStudio.html",
    "title": "CodeFactory Install and Setup | CodeFactory Guidance",
    "keywords": "CodeFactory Install and Setup Use the following steps to install the CodeFactory Runtime Visual Studio Extension: Step 1: Download the CodeFactory for Visual Studio Runtime Get the latest release of the CodeFactory Runtime installer from here . Step 2: Execute the VSIX Installer Simply run the VSIX installer that was downloaded in Step 1 on the same machine that your copy of Visual Studio is already installed on. Step 3: License Key Activation Once the VSIX has installed CodeFactory Runtime, launch Visual Studio, and follow these steps to add your license key (which was included in the email confirmation). From Visual Studio, click the Extensions menu, select CodeFactory > License Information From the [cF] License Information screen, click “Activate License” Copy the license key that was included in your email receipt/confirmation and “Paste From Clipboard” as shown below. Once the license key is pasted/visible in the Enter License text box click “Activate License”. From the [cF] License Information screen you should now see your license information displayed. Click “Close” and your CodeFactory license is now activated. Guidance Once you have completed the setup of CodeFactory you can return to guidance here. CodeFactory Guidance"
  },
  "guidance/howto/Overview.html": {
    "href": "guidance/howto/Overview.html",
    "title": "CodeFactory Guidance | CodeFactory Guidance",
    "keywords": "CodeFactory Guidance In the guidance section you will find walk-through tutorials on how to use different aspects of the CodeFactory environment. Installation and Configuration The following will help with installation and configuration of CodeFactory Installing CodeFactory for Visual Studio (includes the SDK) This will provide step-by-step instructions for installing CodeFactory itself and loading your license key. Install CodeFactory for Visual Studio SDK Examples The following will provide guidance on how to setup and author your own automation using CodeFactory Creating a CodeFactory Project Guidance for creating a new project and displaying the name of a hosted project. This will focus on the following: How to create a CodeFactory project Understanding how NuGet packages are loaded for CodeFactory How to create a CodeFactory command How to format a CodeFactory command How to consume data from the CodeFactory Framework How to create a user interface and display data from CodeFactory Create a CodeFactory Project ASP.Net Core Automation Guidance and walk-through for automation that supports a ASP.Net core web project. This will focus on the following: Usage of project commands Usage of project references Usage of project folders Usage of C# document commands Usage of meta data from C# models Creation of code files Formatting of source code Injection of source code within documents Replacement of source code within documents Dependency Injection Management at a Project Level Auto-implementation of interface members on implementing classes Bounds checking logic automatically added to generated methods Auto-injection of logging for created interface members if Microsoft.Extensions.Logging is referenced at the project level CodeFactory Overview This link will take you to the overview of the CodeFactory platform. CodeFactory Overview"
  },
  "guidance/intro.html": {
    "href": "guidance/intro.html",
    "title": "What is CodeFactory? | CodeFactory Guidance",
    "keywords": "What is CodeFactory? CodeFactory is real-time software delivery tool that runs natively inside of Visual Studio. The focus of CodeFactory is to increase the delivery velocity of building new applications and/or uplift/refactor projects to other technologies. Automation of Construction Delivery Patterns One of the core features of CodeFactory is its ability to use existing application source code as a data model. This is similar in concept to ORM mapping based tools. This allows for the consistent implementation of development patterns which can then auto-generate common application code, which developers would otherwise have to build by hand. The following common use case scenarios are good examples of this concept, although many other scenarios are feasible: Adding/Creating bounds checking within methods Implementation of exception handling logic Implementation of standard logging Automation of dependency injection Auto-creation of different application layers, based on common data models, which can now be identified directly from application source code Auto-generation of data access layers, based on different technologies, which fit the needs of a target delivery pattern Auto-generation of validation logic based on application source code data Auto-generation and logic mapping between service technologies and consumers Automation of Technology Transformation Due to the way in which the CodeFactory SDK was designed - the tooling is very helpful in transforming existing functionality of an application to a new technology implementation. The following are common use case scenarios for technology transformation, but like the Construction Delivery Patterns described above, the examples are not the only scenarios for usage. Read ORM-based data classes and transform into POCO's or to other ORM based implementations Read data classes and generate interface definitions for all classes Read markup languages and use adapters to transform markup from one implementation into another (Example WebForms to Blazor) Read markup languages and update UI implementation frameworks from one implementation to another (Example Modern UI to BootStrap) Lift and shift of application logic from one platform to another (Example mapping logic from .NET Framework to .NET Standard) Migration Mapping of logic from one system to another (Example using UI dialogs to select where logic comes from and where it belongs in a new system) Designed for a Variety of Delivery Approaches CodeFactory directly integrates into the Solution Explorer within Visual Studio. This provides flexibility to the architecture and delivery teams as to when to utilize automation and how that automation should be triggered. The following are a few examples, much like the others above, these are not the only approaches that can be taken. Contract-Driven Approach Interfaces are defined and automation triggers when interfaces need to be implemented. Allowing for a interface based design of the system and the core shell of the entire delivery driven by interface implementations. UI-Driven Approach User Interface dialogs are defined and triggered as a part of an automation command and questions are asked which generates the implementation of new or uplift of application logic. Event-Driven Approach Changes in markup files or .NET application code files like C# will trigger the option to execute automation logic to complete the implementation of logic. Rebuild Approach Logic is run which will rebuild the definition of a target artifact. This is a common approach with ORM based tools. Hybrid Approach This is the most common use case, which some combination of the approaches lsited above to meet a development teams specific delivery needs. Zero-Touch Delivery Tool CodeFactory runs inside of the Visual Studio IDE itself, and behaves like a behind-the-scenes compiler. CodeFactory is a design-time tool and has no application runtime capabilities or dependencies. This means there are no application libraries or technologies that have to be included inside the application you are delivering. Any artifacts that are generated by CodeFactory appear to be standard developer hand-written code. Designed to Build Team-Customized Delivery CodeFactory is a team delivery tool, which means there is no one-size-fits-all delivery process. Its a SDK style platform that simplifies the design of automation to be leveraged by delivery teams. CodeFactory releases a standard set of automation libraries fully implemented. The goal of these libraries is to provide standard guidance scenarios. Many teams will want to extend and modify the guidance to match their own design preferences, which is exactly what the CodeFactory SDK is designed for. The following are the core capabilities of CodeFactory: Solution and Project Management Direct access to the solution and project system hosted inside of Visual Studio. This will include access and partial management of the following items: Solutions Solution Folders Projects Project Folders Project Documents C# Source Code Files Document Management Direct access to any document that is hosted within the solution, which includes the following: Read all content from any document within the solution Replace any/all content within a document Add/remove/replace content at target locations within a document Add new documents Remove documents C# Source Code Model Generation CodeFactory builds real-time data models of C# code files. These models provide access to the following information: Using statements Namespace definitions Attributes Classes Interfaces Structures Delegates Fields Methods Properties Events Type definitions Access to the body of classes, interfaces, structures Access to the body of methods, properties, events Source code management that includes replace, add before, add after, delete on all member objects Source code management that includes replace, add before, add after, delete, beginning, end of all classes,structures, interfaces Source Formatting CodeFactory provides support for formatting of source code regardless of target langauges, including the following: T4 integration to support the use of T4 formatting files to emit the target source code to be generated Source formatter an internal CodeFactory formatter which provides granular source format editing User Interface Management CodeFactory integrates natively into the Visual Studio IDE, allowing developers to build their own custom dialog windows which display as native windows inside of Visual Studio. Build Using .Net Technologies for Fast Adoption CodeFactory was designed to author automation using the C# programming language. All of CodeFactory technologies are written using .NET Framework libraries. (Note: This is a current limitation of the Visual Studio development environment. As Microsoft provide .NET Core integration into Visual Studio, CodeFactory will update at that time.) CodeFactory SDK provides a common set of tools for delivery teams to quickly extend and author their own automation for application delivery."
  },
  "guidance/Introduction/Commands/Overview.html": {
    "href": "guidance/Introduction/Commands/Overview.html",
    "title": "CodeFactory Commands | CodeFactory Guidance",
    "keywords": "CodeFactory Commands When working with CodeFactory you always start with commands. Commands are the trigger point where all CodeFactory functionality originates. Currently all commands are triggered from context menus on individual nodes within Solution Explorer. Each command is comprised of two methods which are raised from internal events that occur within Visual Studio. These events are trigged when a selected Solution Explorer's item content menu is opened. The following describes each of the two methods, their purpose and the different types of commands that are supported in CodeFactory. Command Result Whenever a command is executed, a real time data model is generated based on the type of Visual Studio object that has been selected. The data model is instantly regenerated behind-the-scenes each time the target command is executed. Enable Command When a command is first loaded, it sends the command result to the enable method on the command. This method is called to allow the author of the command to determine whether the command should be visible or hidden to the automation user for use. This feature exists in order to allow automation authors to control execution of automation by hiding or showing commands on the context menu as they desire. This is controlled by simply returning a true or false value to determine if the command should be accessible. If enabled is true, the command will appear inside the context menu. The developer in Visual Studio can then trigger the command to execute by selecting the context menu item. Execute Command Once the developer selects a command to be executed, Visual Studio will run the execute method of the command itself. Like before, a real time data model is instantly passed to the execute method. This is when the automation process starts, and whatever functionality has been authored, will be executed at this time. Solution Explorer Commands CodeFactory current supports the trigger of commands from the Solution Explorer window within Visual Studio. The following are the supported Solution Explorer nodes that can interact with CodeFactory automation commands: Solution Command - Generates a Solution data model SolutionFolder Command - Generates a SolutionFolder data model SolutionDocument Command - Generates a SolutionDocument data model Project Command - Generates a Project data model ProjectFolder - Generates a ProjectFolder data model Document Command - Generates a Document data model C# Document Command - Generates a CSharpSource data model Overview This link takes you back to the CodeFactory Overview CodeFactory Overview"
  },
  "guidance/Introduction/DataModels/Overview.html": {
    "href": "guidance/Introduction/DataModels/Overview.html",
    "title": "CodeFactory Data Models | CodeFactory Guidance",
    "keywords": "CodeFactory Data Models The primary strength of CodeFactory is its ability to generate real time data models directly from your project/solution artifacts within the Visual Studio IDE. This ability makes it possible to do design-time automation when delivering software. In this section we will provide a brief overview of the data models that are generated dynamically by the CodeFactory platform. These data models are used throughout the automation process. Data Models All data models are \"plain old CLR objects\" or POCO's for short. Each data model is implemented as an immutable data class. This approach is used since a change to the underlying data model requires a complete regeneration of the data model from the Visual Studio environment to make sure you have the latest version of all data. For example, making a change to a C# class object would force CodeFactory to regenerate a data model of that file/class object. Data model generation is either triggered during the execution of a new automation process, or from various CodeFactory API calls that will request new copies of data models. Solution Explorer Models (Project System) The following models are directly generated off the legacy and new project systems that are hosted by Visual Studio. The overview of each data model is designed to provide an overview of capabilties. The examples here are not complete and only reflect partial functionality for the purpose of explanation. Please see our help docs for the full description of each data model. Solution Data model that represents the loaded solution. This provides the location of the solution as well as access to the projects within the solution. Solution Folder Data model that represents a virtual folder that is at scope of the solution level. This provides acess to the name of the folder and the children objects which are hosted within this folder. Project Data model that represents a loaded project that is managed in the solution. This provides access to the project location and name, and access to all children objects hosted in the project. Project Reference Data model that represents a reference to a project hosted within the solution. This provides the name of the reference and the target artifact that is being referenced. Project Folder Project folder model represents a folder under a target project. This will contain the path and name of the folder and the list of child objects which are managed under this project folder. Document Document model represents a file which is hosted within a project, project folder, or solution folder. This will contain the path and the name of the file, as well as access to the full contents of the document itself. C# Source Document C# Source Document provides project system access, as well as full access to the C# source code which is hosted within the document itself. C# Language Models - (Source Code) CodeFactory has access to the C# language compiler and can dynamically generate data models that represent the C#-based source code. CodeFactory provides direct access all the way down to member and type level data. In addition, CodeFactory will provide direct access to the raw source code at the target object level. The following data models are auto-generated whenever accessing source code files or directly referenced assemblies. The overview of each data model is designed to provide an example of capabilties and does not list every single data element or function. Please see our help docs for the full description of each data model. Source Code The Source Code model provides access to all elements that were compiled from the source code document. This includes the following: Namespaces Using Statements Classes Interfaces Structures Using Statement Using Statement model provides information on targeted namespaces to use in the code base. This includes the following: Namespace Alias Namespace Statement Namespace model provides the target namespace that other C# code elements are contained in. Attribute Attribute provides a data model of the type of attribute and parameters which have been assigned to the attribute. This includes the following: Name Namespace Named Parameters Constructor Parameters Attribute Parameter Data model that provides the data for a target parameter on an attribute. This includes the following: Name (Optional) Parameter values Attribute Parameter Value Data model that provides a target value that is assigned to an attribute parameter. Enum Enum data model provides the definition of an enumeration and the target values of the enumeration. Class The Class data model provides data on a target class hosted in source code. This will include the following: Attributes Name Namespace Security Scope Keywords Inheritence (Base class and Interfaces) Members (Events, Fields, Methods, Properties) Interface The Interface data model provides data on the target interface definition in source code. This will include the following: Attributes Name Namespace Security Scope Keywords Inheritence (Interfaces) Members (Events, Methods, Properties) Structure The Structure data model provides data on the target structure definition in source code. This will include the following: Attributes Name Namespace Security Scope Keywords Inheritence (Interfaces) Members (Events, Fields, Methods, Properties) Delegate The Delegate model provides data on the definition of a delegate in source code. This will include the following: Name Namespace Parameters Return type Event The Event data model provides data on the definition of an event in source code. This will include the following: Attributes Name Type Security Scope Keywords EventHandlerMethod Definition Field The Field data model provides data on the definition of a field in source code. This will include the following: Attributes Name Type Security Scope Keywords Assigned value Method The Method data model provides data on the definition of a method in source code. This will include the following: Attributes Name Security Scope Keywords Parameters Return Type Method Type Property The Property data model provides data on the definition of a property in source code. This will include the following: Attributes Name Type Property Security Keywords Has Get Get Security Has Set Set Security Parameter The Parameter data model provides data on the definition of a parameter in a method or a delegate. This will include the following: Attributes Name Keywords Default value Type The Type data model provides information about a type that is used in all the above source code definitions. This will include the following: Name Namespace IsValueType IsTuple IsEnum IsArray IsClass IsInterface IsStructure Overview This link takes you back to the CodeFactory Overview CodeFactory Overview"
  },
  "guidance/Introduction/Environment/Overview.html": {
    "href": "guidance/Introduction/Environment/Overview.html",
    "title": "CodeFactory Ecosystem | CodeFactory Guidance",
    "keywords": "CodeFactory Ecosystem CodeFactory is a collection of automation tools which are designed to be used in a native IDE(Integrated-Development-Environment). The decision to integrate into the IDE is based on the fact that CodeFactory is a design-time tool - meaning that no extraneous code artifacts, libraries or runtimes are required to be included with your final solution codebase. In the future, CodeFactory will support more than one IDE, which is why CodeFactory products are named after the platform it's hosted on (i.e. CodeFactory for Visual Studio). In this section we will focus on how CodeFactory integrates into the IDE. CodeFactory for Visual Studio CodeFactory for Visual Studio is an extension of the Visual Studio IDE. CodeFactory was designed to run as an internal service inside Visual Studio, just like Razor, C#, or any number of other services that are part of Visual Studio. This means that once installed, CodeFactory is always 'on' and will automatically load automation commands for use whenever a solution is loaded. CFX - CodeFactory Extension A CodeFactory automation project is saved as complete package within a single file called a CodeFactory Extension (*.cfx). This uses a similar approach as Word uses with DOCX or Excel with XSLX files. All it takes is to copy a CodeFactory Extension, or CFX, file into the root of the your solutions folder. Once the solution is opened in Visual Studio it will automatically load the automation and make it avaiable for use. CodeFactory SDK All automation for CodeFactory was designed and delivered using the CodeFactory SDK. The SDK was designed to provide straightforward access to existing automation and authoring of custom automation. The SDK uses targeted .NET Framework projects that hosts all the supporting libraries that make up the CodeFactory capabilities. The SDK is responsible for packaging the automation and generating the final CFX Files which are used with solutions. Overview This link takes you back to the CodeFactory Overview CodeFactory Overview"
  },
  "guidance/Introduction/Formatting/Overview.html": {
    "href": "guidance/Introduction/Formatting/Overview.html",
    "title": "Source Formatting | CodeFactory Guidance",
    "keywords": "Source Formatting One of the core strengths of CodeFactory is how it manages injection of source code. CodeFactory focuses on taking advantage of the capbilities of the IDE that it integrates into. This allows for flexibility in managing the creation and formatting of source code. This seciton we will focus on the goals for formatting and how we accomplish those goals. Language Agnostic Formatting One of the core goals of CodeFactory is to allow for the usage of data models to define any type of output source code. With this in mind formatting is agnostic by design. You can read in data models and output any target language or markup of your choice. The SDK is designed to allow for this flexibility. In addition, additional extension libraries have been created to assist in formatting and generation of differnt language outputs. Document Driven Updates The CodeFactory platform controls removal, replacement, and injection of source code changes through a document driven approach. This provides for the greatest flexibility with source code management. Keep in mind that CodeFactory runs as part of Visual Studio itself. If a delivery team does not like the provided source formatting tools they are welcome to use any tooling they wish. If the tooling can be called as an external executable or accessed from c# in the .net framework, it can be used with CodeFactory. Model Based Meta Data CodeFactory focuses on the auto generation of model based data to be used with software factories in the generation of additional logic. Out of the box CodeFactory provides the following data model categories to be used with source formatting. Project Models Project models build up meta data about the solution, project, folders and documents in Visual Studio. These models are directly accessed and in som cases used to drive source formatting. Source Code Models - (C# Language) Source models generate full information from the source code file through all the elements down to the member level in C#. This model data allows developers to use that data and output into any target langauge or format that fits the need of the problem they are solving. External Examples Used With Source Formatting As mentioned above, since CodeFactory runs within the Visual Studio process. This allows use to access any framework or third party libraries that also do model generation and use them within the scope of CodeFactory. The following are two examples we have already used to solve automation problems. HTML Agility Pack As part of our WebForms to Blazor project we needed a way to load up HTML into a data model and build markup transformations based on the provided html data. We used the HTML agility pack to read in the HTML data as POCO data classes. From there were were able to use an adapter pattern to read and transform into Blazor based markup. Using CodeFactories built in tools to format the source code then inject back into documents. .Net Framework ADO.NET We needed the ability to read database schema from a database in order to generate and update entities as well as repositories and service classes. To do this we used the built in functionality of ADO that is included in the .net framework to read the schema and auto generate POCO models to be used in automation. CodeFactory Formatters Out of the box CodeFactory has two different source code formatting tools. Both tools are designed to output the formatted source code to be used with the document driven placement approach used in CodeFactory. Both formatting solutions are not tied to any target language or markup format. T4 Source Factory - Provided Formatter The T4 formatting tool that is provided with Visual Studio is fully supported with CodeFactory. Target extended logic is include to allow you to inject any data you want into the T4 template. The T4 template itself is compiled and called in compiled form. Once data is passed into the T4 template the fully formatted output of the T4 is returned as a string. This allows for the author to control where the formatted source is injected into the target document. Source Formatter - Provided Formatter The CodeFactory SDK also has a SourceFormatter class. The source formatter provides extenstions to the existing string builder object. This will allow for the controlling of identation in the content as its added to the formatter. It also allows for indendentation a target number of levels deep to full content that is provided to it. This will also be further extended in time to add additional capabilities. Overview This link takes you back to the CodeFactory Overview CodeFactory Overview"
  },
  "guidance/Introduction/Overview.html": {
    "href": "guidance/Introduction/Overview.html",
    "title": "Overview of CodeFactory | CodeFactory Guidance",
    "keywords": "Overview of CodeFactory This describes the different capabilities and components of the CodeFactory ecosystem. Each section will provide a clear overview of a targeted set of capabilites, as well as guidance. This guide is designed to be read either top to bottom or jump to whichever topic interests you. CodeFactory for VisualStudio Review of the CodeFactory environment and how it integrates with Visual Studio. CodeFactory Environment Data Models Review of the core data models which make up the CodeFactory Platform, describing how data is captured and presented in CodeFactory. CodeFactory Data Models Commands Review of how CodeFactory automation is triggered and consumed. CodeFactory Commands Visual Studio Actions Review of the core API which provides access to Visual Studio. CodeFactory Visual Studio Actions Source Formatting Review of different approaches which are used for formatting generated source code. CodeFactory Source Formatting User Interfaces Review of how user interfaces can be created and used within the Visual Studio environment. CodeFactory User Interface CodeFactory Guidance A variety of \"walk-through\" scenario-driven guidance is provided to help you get started and understand how to use the CodeFactory SDK. CodeFactory Guidance"
  },
  "guidance/Introduction/UI/Overview.html": {
    "href": "guidance/Introduction/UI/Overview.html",
    "title": "User Interface | CodeFactory Guidance",
    "keywords": "User Interface Through out the overview documentation we talk about the fact that CodeFactory is integrated into the target IDE where the product is used. This design approach allows us to maximize the capabilities of delivery automation. Each user interface environent for CodeFactory will be based on the target IDE in which it supports. This is the one part of CodeFactory that many not be reusable across different IDE's. User Interface for Visual Studio CodeFactory out of the box has native dialog window support for Visual Studio. The user interface environment is based on Windows Presentation Foundation or (WPF). This is the native UI framework that is supported by Visual Studio. CodeFactory user interface control is designed to plug directly into a Visual Studio window. The CodeFactory control provides minor extensions to the existing user control object that is part of WPF. Any developer that is familar with XAML based user screens will be able to easily author and creator a dialog window to be displayed in Visual Studio. Overview This link takes you back to the CodeFactory Overview CodeFactory Overview"
  },
  "guidance/Introduction/VsActions/Overview.html": {
    "href": "guidance/Introduction/VsActions/Overview.html",
    "title": "Actions | CodeFactory Guidance",
    "keywords": "Actions Actions are a series of API calls that perform IDE specific functionality. CodeFactory is reponsible for the heavy lifting of all integration with the IDE. These calls are used during the automation process as well as the final output back into the IDE itself. Visual Studio Actions The core actions within CodeFactory today directly interop with Visual Studio itself. Visual Studio actions are accessible at two different levels within the SDK. CodeFactory data models have direct links to Visual Studio actions that directly impact the target data model. At the command level there is direct access to all Visual Studio actions by calling the property VisualStudioActions. The following provides a high level summary of the actions that are avaliable at diffrent levels of the CodeFactory platform. Project System Actions The following are the target actions that are avaliable at the project system level of Visual Studio. Solution Actions These actions are directly executed at the solution level. GetSolutionAsync - Loads the current solution data model CreateSolutionFolderAsync - Creates a new solution folder GetChildrenAsync - Gets all Visual Studio models hosted under the solution GetProjectsAsync - Gets all project data models hosted by the solution Solution Folder Actions These actions are directly executed at the solution folder level. AddDocumentAsync - Creates a new document data model and assigns it to the solution folder AddExitingDocumentAsync - Adds an existing document to the target solution folder AddSolutionFolder - Adds a solution folder under the current solution folder GetChildrenAsync - Gets all Visul Studio models that are children of this solution folder GetParentAsync - Gets the parent Visual Studio model for this solution folder Remove - Removes the solution folder from the solution Project Actions These actions are directly executed at the project level. AddDocumentAsync - Creates a new document and assigns it to the root of the project AddExistingDocumentAsync - Adds an executing document to the root of the project AddProjectFolderAsync - Creates a new project folder under the root of the project GetChildrenAsync - Gets the Visual Studio models that are children of the project GetParentAsync - Gets the Visual Studio model that is the parent to this project GetReferencedProjects - Gets the project data models that are referenced by this project GetReferencesAsync - Genereates the full list of Project Reference data models that support this project Project Reference Actions These actions are directly executed at the project reference level. GetReferencedProjectAsync - Loads the Project data model the project reference is from Project Folder Actions These actions are directly executed at the project folder level. AddDocumentAsync - Creates a new document and adds it to the project folder AddExistingDocumentAsync - Adds an existing document already in the project folder AddProjectFolderAsync - Adds a new project folder that is a child of the current project folder DeleteAsync - Deletes the project folder and all files under the project folder GetCSharpNamespaceAsync - Generates the namespace definition from the project root to the project folder location GetChildrenAsync - Gets all Visual Studio models that are children of this project folder GetParentAsync - Get the parent Visual Studio model of this project folder RemoveAsync - Removes the project folder from the project but does not remove it from the file system Document Actions These actions are directly exected at the document level. AddContentAsync - Adds content to a document starting at a target line number and character position AddContentToBeginningAsync - Adds content at the beginning of the document AddContentToEndAsync - Adds content at the end of the document DeleteAsync - Deletes the document from the hosting solution or project and from the file system GetCSharpSourceModelAsync - If the document is a C# document will load the C# sourcecode model from the document GetChildrenAsync - Builds document models for all documents that are children of this document GetDocumentContentAsContentAsync - Will return the content of the document as a content data model GetDocumentContentAsStringAsync - Will return the content of the document as a string GetParentAsync - Will get the parent Visual Studio model for this document RemoveAsync - Will remove the document from the hosting solution or project but will keep it on the file system RemoveContentAsync - Will remove all content from the document Source Actions These actions are directly executed at the C# document level LoadDocumentFromSourceAsync - Loads a document model from the c# source document User model Actions These actions are directly related to creating and executed customer user models that are hosted in Visual Studio. CreateVsUserControlAsync - Generic method that creates a new instance of a visual studio user control ShowDialogWindowAsync - Displays the target user control in the Visual Studio IDE C# Actions The following actions are directly tied to the C# data models. The implementation of these actions are specific to IDE, but do not change from one IDE to another. Container Actions Container actions focus on actions that occur at the model, model, and structure model levels. Class Actions The following actions occur at the class model level. AddAfterAsync - Add code syntax after the model definition AddBeforeAsync - Add code syntax before the model definition AddToBeginningAsync - Add code syntax to beginning of the body of the model definition AddToEndAsync - Add code syntax to the end of the body of the model definition DeleteAsync - Delete the model definition GetBodySourceLocationAsync - Get the document coordinates where the body starts and ends GetBodySyntaxAsync - Get the raw syntax within the body GetSourceLocationAsync - Get the full model definitions document coordiants where it starts and ends ReplaceAsync - Replaces the entire definition of the model with the provided syntax Interface Actions The following actions occur at the interface model level. AddAfterAsync - Add code syntax after the model definition AddBeforeAsync - Add code syntax before the model definition AddToBeginningAsync - Add code syntax to beginning of the body of the model definition AddToEndAsync - Add code syntax to the end of the body of the model definition DeleteAsync - Delete the model definition GetBodySourceLocationAsync - Get the document coordinates where the body starts and ends GetBodySyntaxAsync - Get the raw syntax within the body GetSourceLocationAsync - Get the full model definitions document coordiants where it starts and ends ReplaceAsync - Replaces the entire definition of the model with the provided syntax Structure Actions The following actions occur at the structure model level. AddAfterAsync - Add code syntax after the model definition AddBeforeAsync - Add code syntax before the model definition AddToBeginningAsync - Add code syntax to beginning of the body of the model definition AddToEndAsync - Add code syntax to the end of the body of the model definition DeleteAsync - Delete the model definition GetBodySourceLocationAsync - Get the document coordinates where the body starts and ends GetBodySyntaxAsync - Get the raw syntax within the body GetSourceLocationAsync - Get the full model definitions document coordiants where it starts and ends ReplaceAsync - Replaces the entire definition of the model with the provided syntax Member Actions Member actions focus on actions that occur at the event, field, method, property levels. Event Actions The following actions occur at the event model level. AddAfterAsync - Adds the syntax after the model definition AddBeforeAsync - Adds the syntax before the model defintion DeleteAsync - Deletes the model GetSourceLocationAsync - Gets the document coordinates where the model starts and ends ReplaceAsync - Replaces the model with the provided syntax Field Actions The following actions occur at the field model level. AddAfterAsync - Adds the syntax after the model definition AddBeforeAsync - Adds the syntax before the model defintion DeleteAsync - Deletes the model GetSourceLocationAsync - Gets the document coordinates where the model starts and ends ReplaceAsync - Replaces the model with the provided syntax Method Actions The following actions occur at the method model level. AddAfterAsync - Adds the syntax after the model definition AddBeforeAsync - Adds the syntax before the model defintion DeleteAsync - Deletes the model GetBodySyntaxAsync - Gets the syntax from the body of the model. GetSourceLocationAsync - Gets the document coordinates where the model starts and ends ReplaceAsync - Replaces the model with the provided syntax Property Actions The following actions occur at the property model level. AddAfterAsync - Adds the syntax after the model definition AddBeforeAsync - Adds the syntax before the model defintion DeleteAsync - Deletes the model GetSourceLocationAsync - Gets the document coordinates where the model starts and ends LoadGetBodySyntaxAsync - Gets the body syntax from the properties get statement LoadSetBodySyntaxAsync - Gets the body syntax from the properties set statement ReplaceAsync - Replaces the model with the provided syntax Other C# Models with Actions The following are other C# models that also have direct actions. Using Statement Actions The following actions apply to the using statement model level. AddAfterAsync - Adds the syntax after the model definition AddBeforeAsync - Adds the syntax before the model defintion DeleteAsync - Deletes the model GetSourceLocationAsync - Gets the document coordinates where the model starts and ends ReplaceAsync - Replaces the model with the provided syntax Attribute Actions The following actions apply to the attribute model level. AddAfterAsync - Adds the syntax after the model definition AddBeforeAsync - Adds the syntax before the model defintion DeleteAsync - Deletes the model GetSourceLocationAsync - Gets the document coordinates where the model starts and ends ReplaceAsync - Replaces the model with the provided syntax Overview This link takes you back to the CodeFactory Overview CodeFactory Overview"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to CodeFactory | CodeFactory Guidance",
    "keywords": "Welcome to CodeFactory This web site provides guidance and API documentaion in support of CodeFactory. Guidance This will provide background information about CodeFactory itself. In addition, it will provide a series of overview and how to guidance for CodeFactory. CodeFactory Guidance SDK Documentation The SDK documentation will provide you access to the API level documentation that supports CodeFactory. SDK Documentation"
  }
}